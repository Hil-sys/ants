
int main() {
    RenderWindow window(VideoMode({ WINDOW_WIDTH, WINDOW_HEIGHT }), "Ant Colony Simulation");
    window.setFramerateLimit(60);

    AntHill anthill(window);
    while (window.isOpen()) {
        while (const optional event = window.pollEvent()) {
            if (event->is<Event::Closed>())
                window.close();
        }

        window.clear(Color::White);

        anthill.update();
        anthill.draw();

        window.display();
    }

    return 0;
}


#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <algorithm>
#include <random>

using namespace std; // добавляем для устранения необходимости писать std::

random_device rd;
mt19937 gen(rd());
uniform_real_distribution<> dis(0, 1);
std::uniform_int_distribution<> child_dist(0, 1); // 50% chance
std::uniform_int_distribution<> role_dist(0, 3);  // 4 роли

// Объявление предварительных классов
class Formicidae;
class Role;
class WorkObserver;
class AntHill;
class Enemy;

// Статические константы
const int MAX_AGE = 10;
const int MAX_ROLES = 4;
const int MAX_SOLDIER_ENEMY = 3;
const int MAX_STOREROOM = 100;
const int MAX_ANTHILL_LEVEL = 12;
const int MAX_ANTHILL_SIZE = 50;
const int WINDOW_WIDTH = 1200;
const int WINDOW_HEIGHT = 800;
const int INFO_AREA_HEIGHT = 100;
const int MAX_AGE = 10;
const int MAX_STOREROOM = 100;
const int MAX_ANTHILL_SIZE = 50;
// Перечисление ролей
enum class RoleType {
    None, Child, Nanny, Soldier, Gatherer, Builder, Shepherd
};

// ----------------------
// АБСТРАКТНЫЙ КЛАСС РОЛЬ
class Role {
public:
    virtual ~Role() {}
    virtual void Work(Formicidae& ant) = 0;
    virtual string name() const = 0;
    virtual Color getColor() const = 0;
};

// ----------------------
// Конкретные роли
class Nanny : public Role {
public:
    void Work(Formicidae& ant) override {}
    string name() const override { return "Nanny"; }
    Color getColor() const override { return Color(255, 192, 203); } // Ðîçîâûé
};
    
class Child : public Role {
public:
    void Work(Formicidae& ant) override {}
    string name() const override { return "Child"; }
    Color getColor() const override { return Color(173, 216, 230); } // Ãîëóáîé
};
    
class Soldier : public Role {
public:
    void Work(Formicidae& ant) override {
        if ((rand() % 100) < 2) {
            Vector2f patrolPoint = anthillShape.getPosition() +
                Vector2f(rand() % static_cast<int>(anthillShape.getSize().x),
                    rand() % static_cast<int>(anthillShape.getSize().y));
            ant.setTarget(patrolPoint);
        }
    }
    string name() const override { return "Soldier"; }
    Color getColor() const override { return Color::Red; }
};

//class Gatherer : public Role {
//public:
//    void Work(Formicidae& ant) override {
//        cout << "Собиратель собирает еду\n";
//    }
//    string name() const override { return "Собиратель"; }
//};

class Builder : public Role {
public:
    void Work(Formicidae& ant) override {
        if (!ant.carryingItem) {
            if (!branches.empty()) {
                
                (time(NULL));
                int idx = rand() % branches.size();
                ant.setTarget(branches[idx].getPosition());
                ant.carryingItem = true;
            }
        }
        else if (ant.carryingItem) {
            ant.setTarget(anthillShape.getPosition() +
                Vector2f(anthillShape.getSize().x / 2, anthillShape.getSize().y / 2));
            if (Vector2f(ant.position - ant.target).length() < 10.0f) {
                ant.carryingItem = false;
                branchesCount++;
            }
        }
    }
    string name() const override { return "Builder"; }
    Color getColor() const override { return Color::Blue; }
};
    
class Shepherd : public Role {
public:
    void Work(Formicidae& ant) override {}
    string name() const override { return "Shepherd"; }
    Color getColor() const override { return Color::Green; }
};

// ----------------------
// МУРАВЕЙ
class Formicidae {
public:
    int age = 0;
    int health = 100;
    RoleType currentRoleType = RoleType::None;
    shared_ptr<Role> role;
    bool alive = true;
    bool grownUp = false; // добавляем флаг
    Vector2f position;
    Vector2f target;
    bool carryingItem = false;
    float speed = 1.0f + (rand() % 3);
    void ageUp() {
        age++;
        if (age >= 4 && !grownUp) {
            grownUp = true;
            // При взрослении назначаем роль солдата или Builder или нянька по 33%
            double r = dis(gen);
            if (r < 0.33) {
                role = make_shared<Soldier>();
                currentRoleType = RoleType::Soldier;
            }
            else if (r >= 0.33 && r < 0.66) {
                role = make_shared<Builder>();
                currentRoleType = RoleType::Builder;
            }
            else if (r >= 0.66) {
                role = make_shared<Nanny>();
                currentRoleType = RoleType::Nanny;
            }
        }
        if (age >= 19) {
            alive = false; // убираем муравья из муравейника
            return; // досрочно выходим из метода
        }
        else {
            updateRole();
        }
    }

    void updateRole() {
        if (age < 4) {
            role = make_shared<Child>(); currentRoleType = RoleType::Child;
        }
        else if (age >= 13) {
            role = make_shared<Shepherd>(); currentRoleType = RoleType::Shepherd;
        }
    }

    void work() {
        if (role && alive) role->Work(*this);
    }

    void receiveDamage(int damage) {
        health -= damage;
        if (health <= 0) {
            alive = false;
        }
    }
    Formicidae(Vector2f pos) : position(pos), target(pos) {}

    void update() {
        // Äâèæåíèå ê öåëè
        Vector2f direction = target - position;
        float length = sqrt(direction.x * direction.x + direction.y * direction.y);
        if (length > 1.0f) {
            direction /= length;
            position += direction * speed;
        }
    }

    void setTarget(Vector2f newTarget) {
        target = newTarget;
    }
};

class Enemy {
    public:
        Vector2f position;
        Vector2f target;
        int strength = 50;
        float speed = 1.5f;
        bool alive = true;
    
        Enemy(Vector2f pos) : position(pos), target(pos) {}
    
        void update() {
            Vector2f direction = target - position;
            float length = sqrt(direction.x * direction.x + direction.y * direction.y);
            if (length > 1.0f) {
                direction /= length;
                position += direction * speed;
            }
        }
    };

// ---------------------
// ИНТЕРФЕЙС ОПОВЕЩЕНИЙ
class INotifier {
public:
    virtual ~INotifier() {}
    virtual void notify(const string& message) = 0;
};

class Observer {
public:
    virtual void update(const string& event) = 0;
};

// ----------------------
class AntHill {
    private:
        
    
    public:
        AntHill(RenderWindow& win) : window(win), gen(rd()), dis(0, 1) {
            if (!font.openFromFile("arial.ttf")) {
                cerr << "Failed to load font!" << endl;
            }
    
            // Íàñòðîéêà èãðîâûõ îáëàñòåé
            infoArea.setSize(Vector2f(WINDOW_WIDTH, INFO_AREA_HEIGHT));
            infoArea.setPosition({ 0, WINDOW_HEIGHT - INFO_AREA_HEIGHT });
            infoArea.setFillColor(Color(200, 200, 200));
    
            anthillShape.setSize(Vector2f(200, 200));
            anthillShape.setPosition({ 50, 300 });
            anthillShape.setFillColor(Color(150, 75, 0));
    
            farmlandShape.setSize(Vector2f(300, 100));
            farmlandShape.setPosition({ 50, 50 });
            farmlandShape.setFillColor(Color(139, 69, 19));
    
            forestShape.setSize(Vector2f(300, 200));
            forestShape.setPosition({ WINDOW_WIDTH - 350, 50 });
            forestShape.setFillColor(Color(34, 139, 34));
    
            // Ñîçäàíèå âåòîê
            for (int i = 0; i < 20; ++i) {
                RectangleShape branch(Vector2f(20, 5));
                int xpos = 600 + rand() % 400;
                int ypos = 500 + rand() % 200;
                branch.setPosition(Vector2f(xpos, ypos));
                branch.setFillColor(Color(139, 69, 19));
                branch.setRotation(sf::degrees(rand() % 360));
                branches.push_back(branch);
            }
    
            // Ñîçäàíèå íà÷àëüíûõ ìóðàâüåâ
            createInitialAnts();
        }
    
        void createInitialAnts() {
            Vector2f anthillCenter = anthillShape.getPosition() + Vector2f(anthillShape.getSize().x / 2, anthillShape.getSize().y / 2);
    
            // Ñîçäàåì íåñêîëüêî ìóðàâüåâ ðàçíûõ òèïîâ
            for (int i = 0; i < 10; ++i) {
                Formicidae ant(anthillCenter);
                ant.role = make_shared<Child>();
                ant.currentRoleType = RoleType::Child;
                ants.push_back(ant);
            }
        }
    
        void update() {
            // Îáíîâëåíèå ìóðàâüåâ
            for (auto& ant : ants) {
                ant.update();
    
                // Ëîãèêà ïîâåäåíèÿ â çàâèñèìîñòè îò ðîëè
                if (ant.role) {
                    switch (ant.currentRoleType) {
                    case RoleType::Soldier:
                        // Ñîëäàòû ïàòðóëèðóþò âîêðóã ìóðàâåéíèêà
                        
                        break;
    
                    case RoleType::Builder:
                        // Ñòðîèòåëè ñîáèðàþò âå
                    case RoleType::Shepherd:
                        // Ïàñòóõè õîäÿò ìåæäó ìóðàâåéíèêîì è ïàøíåé Çàêîí÷èì ñ íèìè ïîçæå
                        break;
                    }
                }
            }
    
            // Îáíîâëåíèå âðàãîâ
            for (auto& enemy : enemies) {
                enemy.update();
            }
            // Ñëó÷àéíîå ïîÿâëåíèå âðàãîâ
            if ((rand() % 1000) < 2 && day>10) {
                spawnEnemy();
            }
        }
    
        void spawnEnemy() {
            Vector2f spawnPoint(forestShape.getPosition().x + forestShape.getSize().x / 2,
                forestShape.getPosition().y + forestShape.getSize().y / 2);
            Enemy enemy(spawnPoint);
            enemy.target = anthillShape.getPosition() + Vector2f(anthillShape.getSize().x / 2, anthillShape.getSize().y / 2);
            enemies.push_back(enemy);
        }
    
        void draw() {
            // Îòðèñîâêà èãðîâûõ îáëàñòåé
            window.draw(anthillShape);
            window.draw(farmlandShape);
            window.draw(forestShape);
    
            // Îòðèñîâêà âåòîê
            for (auto& branch : branches) {
                window.draw(branch);
            }
    
            // Îòðèñîâêà ìóðàâüåâ
            for (auto& ant : ants) {
                CircleShape antShape(5);
                if (ant.role) {
                    antShape.setFillColor(ant.role->getColor());
                }
                else {
                    antShape.setFillColor(Color::White);
                }
                antShape.setPosition(ant.position);
                window.draw(antShape);
    
                // Åñëè ìóðàâåé íåñåò ïðåäìåò
                if (ant.carryingItem) {
                    RectangleShape item(Vector2f(3, 3));
                    item.setFillColor(Color(139, 69, 19));
                    item.setPosition(ant.position + Vector2f(5, 5));
                    window.draw(item);
                }
            }
    
            // Îòðèñîâêà âðàãîâ
            for (auto& enemy : enemies) {
                CircleShape enemyShape(8);
                enemyShape.setFillColor(Color::Black);
                enemyShape.setPosition(enemy.position);
                window.draw(enemyShape);
            }
    
            // Îòðèñîâêà èíôîðìàöèîííîé ïàíåëè
            window.draw(infoArea);
            drawInfoText();
            count++;
            if (count == 200) {
                day++;
                for (auto ant : ants) {
                    ant.ageUp();
                }
                count = 0;
            }
        }
    
        void drawInfoText() {
            Text infoText(font);
            infoText.setCharacterSize(16);
            infoText.setFillColor(Color::Black);
    
            stringstream ss;
            ss << "Day: " << day << " | Berries: " << berries << " | Branches: " << branchesCount
                << " | Ants: " << ants.size() << "/" << maxAnts << " | Level: " << anthillLevel;
            infoText.setString(ss.str());
            infoText.setPosition({ 10, WINDOW_HEIGHT - INFO_AREA_HEIGHT + 10 });
            window.draw(infoText);
    
            // Ïîäñ÷åò ìóðàâüåâ ïî ðîëÿì
            int soldiers = 0, builders = 0, shepherds = 0, nannies = 0, children = 0;
            for (auto& ant : ants) {
                if (ant.role) {
                    if (ant.currentRoleType == RoleType::Soldier) soldiers++;
                    else if (ant.currentRoleType == RoleType::Builder) builders++;
                    else if (ant.currentRoleType == RoleType::Shepherd) shepherds++;
                    else if (ant.currentRoleType == RoleType::Nanny) nannies++;
                    else if (ant.currentRoleType == RoleType::Child) children++;
                }
            }
    
            ss.str("");
            ss << "Roles: Soldiers: " << soldiers << " | Builders: " << builders
                << " | Shepherds: " << shepherds << " | Nannies: " << nannies
                << " | Children: " << children;
            infoText.setString(ss.str());
            infoText.setPosition({ 10, WINDOW_HEIGHT - INFO_AREA_HEIGHT + 35 });
            window.draw(infoText);
        }
    };
// Класс "Муравейник"
class AntHill : public INotifier {
private:
    int size = 10;
    int maxSize = MAX_ANTHILL_SIZE;
    int food = 100;
    int maxFood = MAX_STOREROOM;
    int maxAnts = 50;
    int branches = 0;
    int level = 1;
    int maxBranches = 300; // произвольный максимум веточек
    RenderWindow& window;
    Font font;
    RectangleShape infoArea;
    
    // Èãðîâûå îáúåêòû
    RectangleShape anthillShape;
    RectangleShape farmlandShape;
    RectangleShape forestShape;
    vector<RectangleShape> branches;
    vector<Formicidae> ants;
    vector<Enemy> enemies;
    
    // Ðåñóðñû
    int day = 1;
    int count=0;
    int berries = 100;
    int branchesCount = 0;
    int anthillLevel = 1;
    int maxAnts = 50;
    
    // Ãåíåðàöèÿ ñëó÷àéíûõ ÷èñåë
    random_device rd;
    mt19937 gen;
    uniform_real_distribution<> dis;

    vector<shared_ptr<Formicidae> > ants;
    vector<Observer*> observers;
public:
    AntHill(RenderWindow& win) : window(win), gen(rd()), dis(0, 1) {
    if (!font.openFromFile("arial.ttf")) {
        cerr << "Failed to load font!" << endl;
    }

    // Íàñòðîéêà èãðîâûõ îáëàñòåé
    infoArea.setSize(Vector2f(WINDOW_WIDTH, INFO_AREA_HEIGHT));
    infoArea.setPosition({ 0, WINDOW_HEIGHT - INFO_AREA_HEIGHT });
    infoArea.setFillColor(Color(200, 200, 200));

    anthillShape.setSize(Vector2f(200, 200));
    anthillShape.setPosition({ 50, 300 });
    anthillShape.setFillColor(Color(150, 75, 0));

    farmlandShape.setSize(Vector2f(300, 100));
    farmlandShape.setPosition({ 50, 50 });
    farmlandShape.setFillColor(Color(139, 69, 19));

    forestShape.setSize(Vector2f(300, 200));
    forestShape.setPosition({ WINDOW_WIDTH - 350, 50 });
    forestShape.setFillColor(Color(34, 139, 34));

    // Ñîçäàíèå âåòîê
    for (int i = 0; i < 20; ++i) {
        RectangleShape branch(Vector2f(20, 5));
        int xpos = 600 + rand() % 400;
        int ypos = 500 + rand() % 200;
        branch.setPosition(Vector2f(xpos, ypos));
        branch.setFillColor(Color(139, 69, 19));
        branch.setRotation(sf::degrees(rand() % 360));
        branches.push_back(branch);
    }
    void addAnt(shared_ptr<Formicidae> ant) {
        if (ants.size() < maxAnts && size >= static_cast<int>(ants.size()) + 1 && food >= 5) {
            addFood(-5);
            ants.push_back(ant);
            cout << "У нас пополнение!\n"; 
        }
    }
    void removeDeadAnts() {
        ants.erase(std::remove_if(ants.begin(), ants.end(),
            [](const shared_ptr<Formicidae>& ant) {
                if (ant->health <= 0) {
                    cout << "Сегодня от голода умер " << (ant->role ? ant->role->name() : "без роли") << "\n";
                    return true;
                }
                else if (!ant->alive) {
                    cout << "Сегодня от старости умер " << (ant->role ? ant->role->name() : "без роли") << "\n";
                    return true;
                }
                return false;
            }),
            ants.end());
    }

    void addBranches(int amount) {
        branches += amount;
        if (branches > maxBranches) branches = maxBranches;
        if (branches < 0) branches = 0;
    }
    void update() {
        for (auto& ant : ants) {
            ant.update();
        }
    void firstDay() {
        // Инициализация генератора случайных чисел
        auto newAnt = make_shared<Formicidae>();
        newAnt->role = make_shared<Nanny>();
        newAnt->currentRoleType = RoleType::Nanny;
        newAnt->age = 4;
        newAnt->grownUp = true;



        addAnt(newAnt);

        for (int i = 0; i < (maxAnts / 2) - 1; ++i) {
            auto newAnt = make_shared<Formicidae>();

            // 50% chance для ребенка, 50% для случайной роли
            if (child_dist(gen)) {
                newAnt->role = make_shared<Child>();
                newAnt->currentRoleType = RoleType::Child;
            }
            else {
                // Генерация случайной роли для взрослого муравья
                switch (role_dist(gen)) {
                case 0:
                    newAnt->role = make_shared<Nanny>();
                        newAnt->currentRoleType = RoleType::Nanny;
                        newAnt->age = 4;
                        newAnt->grownUp = true;
                    break;
                case 1:
                    newAnt->role = make_shared<Soldier>();
                    newAnt->currentRoleType = RoleType::Soldier;
                    newAnt->age = 4;
                    newAnt->grownUp = true;
                    break;
                case 2:
                    newAnt->role = make_shared<Builder>();
                    newAnt->currentRoleType = RoleType::Builder;
                    newAnt->age = 4;
                    newAnt->grownUp = true;
                    break;
                case 3:
                    newAnt->role = make_shared<Shepherd>();
                    newAnt->currentRoleType = RoleType::Shepherd;
                    newAnt->age = 13; // Пастухи старше
                    newAnt->grownUp = true;
                    break;
                }
            }
            addAnt(newAnt);
        }
    }
    void simulateDay() {
        for (auto& ant : ants) {
            if (ant->alive) {
                if (ant->currentRoleType == RoleType::Shepherd) {
                    addFood(8);
                }
                if (ant->currentRoleType == RoleType::Nanny) {
                    addFood(5);
                }
                if (ant->currentRoleType == RoleType::Builder) {
                    addBranches(1); // сбор одного веточки
                }
                if (branches >= 3) {
                    size += 1; // увеличение муравейника
                    if (size > maxSize) size = maxSize;
                    branches -= 3; // расход веточек
                }
                ant->work();
                ant->ageUp();
            }
            
        }
        
        removeDeadAnts();
        /*ants.erase(remove_if(ants.begin(), ants.end(),
            [](const shared_ptr<Formicidae>& a) { return !a->alive; }),
            ants.end());*/

        // Обновление размера муравейника при достаточном уровне еды
        /*if (food > maxFood * 0.5 && size < maxSize) {
            size += 1;
            maxAnts = size;
        }*/
        

        // Пример добавления нового муравья-няни в начале дня
        auto newAnt = make_shared<Formicidae>();
        newAnt->role = make_shared<Child>();
        newAnt->currentRoleType = RoleType::Child;

        

        addAnt(newAnt); // добавляем в муравейник с проверками

        // Регулировка еды
        /*if (food < maxFood) {
            food += rand() % 10;
            if (food > maxFood) food = maxFood;
        }*/
        
        for (auto& ant : ants) {
            if (ant->alive) {
                if (ant->currentRoleType == RoleType::Child) {
                    removeFood(2);
                }
                else if (ant->currentRoleType == RoleType::Nanny) {
                    removeFood(1);
                }
                else if (ant->currentRoleType == RoleType::Soldier) {
                    removeFood(3);
                }
                else if (ant->currentRoleType == RoleType::Builder) {
                    removeFood(3);
                }
                else if (ant->currentRoleType == RoleType::Shepherd) {
                    removeFood(2);
                }
            }
        }
        if (food == 0) {
            cout << "Муравьи голодают!\n";
            for (auto& ant : ants) {
                if (ant->alive) {
                    if (ant->currentRoleType == RoleType::Child) {
                        ant->health -= 50;
                    }
                    else ant->health -= 25;
                }
            }
        }
    }


    void addFood(int amount) {
        if (food + amount <= maxFood)
            food += amount;
        else
            food = maxFood;
    }

    void removeFood(int amount) {
        if (food - amount >= 0)
            food -= amount;
        else
            food = 0;
    }

    void notify(const string& message) override {
        for (auto* obs : observers)
            obs->update(message);
    }

    void addObserver(Observer* obs) { observers.push_back(obs); }
    void removeObserver(Observer* obs) {
        observers.erase(remove(observers.begin(), observers.end(), obs), observers.end());
    }
};

// ----------------------
// Враг
class Enemy {
public:
    int strength = 50;

    void attack(AntHill& hill) {
        if (hill.ants.empty()) return;

        // Случайный выбор жертв
        random_shuffle(hill.ants.begin(), hill.ants.end());

        int countToKill = min<int>(1 + rand() % 3, hill.ants.size());

        // Перед удалением собираем информацию о ролях
        vector<string> killedRoles;
        for (int i = 0; i < countToKill; ++i) {
            if (hill.ants[i]->role) {
                killedRoles.push_back(hill.ants[i]->role->name());
            }
            else {
                killedRoles.push_back("Без роли");
            }
        }

        // Удаляем муравьев
        hill.ants.erase(hill.ants.begin(), hill.ants.begin() + countToKill);

        // Выводим информацию об убитых
        cout << "Убито муравьев: " << countToKill << endl;
        cout << "Роли убитых: ";
        for (const auto& role : killedRoles) {
            cout << role << ", ";
        }
        cout << endl;

        // Гарантированная кража
        int foodStolen = min(1 + rand() % 25, hill.food);
        hill.food -= foodStolen;

        hill.notify("Враг украл " + to_string(foodStolen) + " еды!");
    }
};

// ----------------------
// Класс "Информер" для оповещений
class EventManager : public Observer {
public:
    string name;
    EventManager(const string& n) : name(n) {}
    void update(const string& event) override {
        cout << "[" << name << "] Оповещение: " << event << "\n";
    }
};

// --------------------------
// Основная функция
int main() {
    setlocale(LC_ALL, "Russian");
    AntHill hill;

    // Создаем подписчиков
    EventManager em1("Информёр 1");
    EventManager em2("Информёр 2");
    hill.addObserver(&em1);
    hill.addObserver(&em2);

    


    for (int day = 0; day < 26; ++day) {
        cout << "День " << (day) << "\n";

        if (day == 9) {
            Enemy enemy;
            enemy.attack(hill);
        }
        if (day == 0)
            hill.firstDay();
        else
            hill.simulateDay();

        cout << "Статистика:\n";
        cout << "Размер муравейника: " << hill.size << "\n";
        cout << "Количество муравьев: " << hill.ants.size() << "\n";
        cout << "Веточки: " << hill.branches << "\n";
        cout << "Количество еды: " << hill.food << "\n";

        int countChild = 0, countNanny = 0, countSoldier = 0, countGatherer = 0, countBuilder = 0, countShepherd = 0;
        for (auto& ant : hill.ants) {
            switch (ant->currentRoleType) {
            case RoleType::Nanny: countNanny++; break;
            case RoleType::Child: countChild++; break;
            case RoleType::Soldier: countSoldier++; break;
            case RoleType::Gatherer: countGatherer++; break;
            case RoleType::Builder: countBuilder++; break;
            case RoleType::Shepherd: countShepherd++; break;
            default: break;
            }
        }

        cout << "Роли:\n";
        cout << "\tДети: " << countChild << "\n";
        cout << "\tНяни: " << countNanny << "\n";
        cout << "\tСолдаты: " << countSoldier << "\n";
        cout << "\tСтроители: " << countBuilder << "\n";
        cout << "\tПастухи: " << countShepherd << "\n";

        cout << "------------------------\n";
    }

    return 0;
}
